План рассказа:

С2
Графическим приложениям требуется совершать множество вызовов отрисовки,
и каждый требует подготовки

Масштаб современных приложений требует большой
объем выставления состояний каждый кадр. Так, в кадре из игры Енлистед...

Потому создание оптимизированной системы для выставления состояний
позволит высвободить ресурсы как времени выполнения, так и разработчиков

С3
Просто читаю

С4
Стоит отметить, что в индустрии нет консенсуса, а большинство решений
проприетарны.

Тем не менее, большинство движков используют интерпретацию метаданных
шейдеров и ресурсов для объектов сцены, и ручное выставления для
основного пайплайна отрисовки. Также многие движки поддерживают
специальные оптимизации для частных случаев систем и алгоритмов отрисовки.

На их фоне выделяется Дагор, где система, основанная на генерации кода
используется почти для всех случаев

Рассмотрим его подробнее

С5
В Дагоре генерация кода выставления состояний включена в компиляцию специального
языка дсхл, с помощью которого определяются все графические и вычислительные
конвейреры в движке. 

На слайде изображена высокоуровневая структура языка и его компиляции.

Исходные файлы содержат определения шейдеров в виде фрагментов хлсл,
объявления переменных, задающих высокоуровневые параметры алгритмов графики,
и блоки на подъязыке прешейдер, с помощью которого определяются состояния
и способ их вычисления на основе переменных.

Выходные данные компиляции включают в себя описания переменных,
шейдерные модули и специальных байткод для выставления состояний

С6
Байткод выставления состояний генерируется на основе прешейдера,
вместе с объявлениями данных состояний в шейдерном коде на хлсл.

На данном слайде можно видеть пример синтаксиса переменных и прешейдера,
и результата его компиляции -- объявления в шейдере (указка) и байткод (указка)

Байткод содержит три типа инструкций
1) Чтение переменных (указка)
2) Вычисления (указка)
3) Выставления (указка)

С7
Во время выполнения вызов отрисовки работает следующим образом

Сначала, в коде приложения вычисляются и выставляются значения переменных
Затем, движку отдается команда отрисовки

При выполнении команды движок выбирает шейдерные модули, процедуру
байткода состояний и исполняет ее при помощи виртуальной машины с регистровой
памятью

В результате выполнения байткода все конкретные параметры оказываются вычислены
на основе высокоуровневых переменных состояния и выставлены, после
чего производится вызов конвейера.

С8
Интерфейс прешейдера и переменных хорошо подходит для целей работы, тем не менее
его реализация обладает недостатками

Узким местом существующей системы является исполнение байткода, потому в
данной работе предлагается

С9
от него отказаться, заменив на более эффективный способ вычислений.

С10
А именно код на С++, собираемый в динамическую библиотеку.
В предложенном решении добавляется этап кодогенерации на основе
прешейдера с последующим вызовом компилятора С++ для сборки библиотеки.

С11
Рассмотрим генерацию кода подробнее. Объявления в hlsl остаются без измененений,
Но там, где раньше компилировалась процедура с байткодом,

С12
в предложенном решении собирается функция на С++,
в которой переменные считываются по прямым ссылкам, вычисления транслируются
напрямую, а выставления производятся с помощью вызовов функций графического
API.

С13
Интерфейсом динамической библиотеки является массив указателей на
все собранные процедуры, который возвращается коду движка из единтсвенной
публично доступной функции init.

С14
На этапе выполнения теперь отпадает необходимость в виртуальной машине и
исполнении байткода --

С15
вместо этого, происходит прямой вызов функции
из загруженной динамической библиотеки по индексу в массиве,
и в рамках этого вызова все те же этапы выполняются в нативном коде.

Кроме перехода к нативному коду, было реализовано еще несколько оптимизаций.

С16
Во-первых, размер сгенерированного кода был
проблемой. Это происходило из-за условных конструкций в dshl,
которые позволяют генерировать различные вариации одной и той же
шейдерной программы.

В данном примере (указка) одна условная конструкция приводит к генерации
двух процедур. При наличии более сложных конструкций размер кода растет
экспоненциально.

С17
Для решения этой проблемы был реализован альтернативный режим компиляции,
в котором условные конструкции транслируются в соответствующие конструкции
в С++. 

Данный режим уменьшает размер кода в 2.5 раза, в то время как
ухудшение производительности было незначительным.

С18
Во-первых, для численных параметров был реализован сбор значений в буфер
на аппаратном стеке, после чего выставление производится одним вызовом.

Это позволило ускорить исполнение на 25-50% и уменьшить размер кода в 1.5 раза.
При использовании обоих оптимизаций размер динамической библиотеки
оказался меньше общего размера байткода в предыдущем решении.

С19
Кроме производительности, решение должно было быть кроссплатформенным.

За реализацию вызовов выставления отвечала библиотека d3d, поддерживающая
все необходимые графические API

В рамках работы необходимо было реализовать поддержку динамических библиотек
на всех поддерживаемых платформах -- Windows, PS, Xbox, Linux, Mac, Android,
iOS и Nintendo Switch.

На всех вышеперечисленных платформах решение поддерживается в 
девелпомент-сборках

С20
А на отмеченных на этом слайде платформах решение полностью интегрировано.

С21
(пауза) Наконец, перейдем к сравнению производительности!
Тестирование проводилось в игре Enlisted на PC и Xbox One S,
на статической сцене и динамической сцене.
Сравнивались общее время выполнения функций выставления состояния
за кадр и размер кода.

С22
(еще одна пауза)
На графиках слева изображены измерения для PC, а справа -- для Xbox
Для каждой платформы слева приведены замеры для статической сцены, а справа
-- для динамической. 

На каждом графике представлены значения для
(указка) байткода, левый столбик
(указка) С++ без описанных оптимизаций, следующий
(указка) С++ с буфферизацией численных данных, следующий
(указка) И С++ с всеми оптимизациями и динамическим ветвлением
         в самом левом столбике

На этом слайде приведены замеры времени выполнения:
как вы можете видеть, оптимизированный код на С++ в 4 раза быстрее на PC,
и почти в 2 раза быстрее на Xbox, причем на Xbox абсолютное улучшение
производительности в 0.7мс, что составляет 4% кадра при частоте в 60 герц.

Также стоит отметить, что версия с динамическим ветвлением 
практически так же производительна, как и версия без ветвления,

С23
... что делает ее предпочтительной благодаря размерам кода!

На данном графике изображен размер кода. Как вы можете видеть, в то
время как версии без ветвления занимают в 2 и в 3 раза больше памяти,
нежели байткод, версия с динамическим ветвлением оказывается 
в полтора раза меньше байткода.

С24
Таким образом, цель работы я считаю выполненной

В ходе работы была разработана новая система выставления состояний для
Dagor Engine, эта система была интегрирована в проект Enlisted,
а сравнение производительности показало улучшение быстродейтвия
в от 2 до 4 раз, при уменьшении размера кода в 1.5 раза.
